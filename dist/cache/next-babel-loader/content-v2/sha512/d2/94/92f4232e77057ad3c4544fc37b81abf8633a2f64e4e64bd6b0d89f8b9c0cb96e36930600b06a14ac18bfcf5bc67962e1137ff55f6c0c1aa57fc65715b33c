{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst jwt = require('jsonwebtoken');\n\nconst mongoose = require('mongoose');\n\nconst uniqueValidator = require('mongoose-unique-validator');\n\nconst {\n  ServerError\n} = require('../server/ServerUtils');\n\nconst UsersSchema = new mongoose.Schema({\n  avatar: {\n    type: String,\n    required: true\n  },\n  name: {\n    type: String,\n    required: false,\n    default: ''\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  username: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  description: {\n    type: String,\n    required: false,\n    default: ''\n  },\n  password: {\n    type: String,\n    required: true\n  },\n  lastLogin: {\n    type: Date,\n    default: Date.now()\n  }\n});\nUsersSchema.plugin(uniqueValidator);\nconst User = mongoose.models.User || mongoose.model('User', UsersSchema);\n\nasync function ping(token) {\n  return new Promise((resolve, reject) => {\n    jwt.verify(token, process.env.TOKEN_SECRET, async (err, decodedInfo) => {\n      if (err) {\n        reject(new ServerError(401, 'Not authenticated'));\n        return;\n      }\n\n      const {\n        _id\n      } = decodedInfo;\n      const user = await findUserBy({\n        _id\n      });\n\n      if (!user) {\n        reject(new ServerError(404, \"User doesn't exist anymore!\"));\n        return;\n      }\n\n      resolve(user);\n    });\n  });\n}\n\nfunction sanitize(user) {\n  const sanitizedUser = _objectSpread({}, user.toObject());\n\n  const propsToDelete = ['_id', '__v', 'password'];\n  propsToDelete.forEach(prop => delete sanitizedUser[prop]);\n  return sanitizedUser;\n}\n\nasync function findUserBy(filters) {\n  const user = await User.findOne(filters);\n  return user || null;\n}\n\nmodule.exports = {\n  User,\n  UsersSchema,\n  ping,\n  sanitize,\n  findUserBy\n};","map":{"version":3,"sources":["C:/Users/didi/Desktop/frontend.ro/shared/user.shared-model.js"],"names":["jwt","require","mongoose","uniqueValidator","ServerError","UsersSchema","Schema","avatar","type","String","required","name","default","email","unique","username","description","password","lastLogin","Date","now","plugin","User","models","model","ping","token","Promise","resolve","reject","verify","process","env","TOKEN_SECRET","err","decodedInfo","_id","user","findUserBy","sanitize","sanitizedUser","toObject","propsToDelete","forEach","prop","filters","findOne","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-var-requires */\r\nconst jwt = require('jsonwebtoken');\r\nconst mongoose = require('mongoose');\r\nconst uniqueValidator = require('mongoose-unique-validator');\r\nconst { ServerError } = require('../server/ServerUtils');\r\n\r\nconst UsersSchema = new mongoose.Schema({\r\n  avatar: { type: String, required: true },\r\n  name: { type: String, required: false, default: '' },\r\n  email: { type: String, required: true, unique: true },\r\n  username: { type: String, required: true, unique: true },\r\n  description: { type: String, required: false, default: '' },\r\n  password: { type: String, required: true },\r\n  lastLogin: { type: Date, default: Date.now() },\r\n});\r\nUsersSchema.plugin(uniqueValidator);\r\n\r\nconst User = mongoose.models.User || mongoose.model('User', UsersSchema);\r\n\r\nasync function ping(token) {\r\n  return new Promise((resolve, reject) => {\r\n    jwt.verify(token, process.env.TOKEN_SECRET, async (err, decodedInfo) => {\r\n      if (err) {\r\n        reject(new ServerError(401, 'Not authenticated'));\r\n        return;\r\n      }\r\n\r\n      const { _id } = decodedInfo;\r\n\r\n      const user = await findUserBy({ _id });\r\n      if (!user) {\r\n        reject(new ServerError(404, \"User doesn't exist anymore!\"));\r\n        return;\r\n      }\r\n\r\n      resolve(user);\r\n    });\r\n  });\r\n}\r\n\r\nfunction sanitize(user) {\r\n  const sanitizedUser = { ...user.toObject() };\r\n  const propsToDelete = ['_id', '__v', 'password'];\r\n\r\n  propsToDelete.forEach((prop) => delete sanitizedUser[prop]);\r\n\r\n  return sanitizedUser;\r\n}\r\n\r\nasync function findUserBy(filters) {\r\n  const user = await User.findOne(filters);\r\n\r\n  return user || null;\r\n}\r\n\r\nmodule.exports = {\r\n  User,\r\n  UsersSchema,\r\n  ping,\r\n  sanitize,\r\n  findUserBy,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}