{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable vars-on-top */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-var */\nimport { FEEDBACK_TYPES } from '~/services/Constants';\n// import './monaco.scss';\nconst LETTER_WIDTH = 7.75;\n\nfunction extendWithDecorate(editor) {\n  editor.decorationsMap = {};\n\n  editor.decorate = function decorate(data, ...args) {\n    let currentRange = new window.monaco.Range(...args);\n    data.type = data.type || FEEDBACK_TYPES.PRAISE;\n\n    if (args.length === 1 && args[0] instanceof window.monaco.Range) {\n      [currentRange] = args;\n    }\n\n    let textModel = this.getModel();\n\n    if (Object.keys(this.decorationsMap).map(id => textModel.getDecorationRange(id)).find(rangeInfo => window.monaco.Range.areIntersecting(rangeInfo, currentRange))) {\n      return;\n    }\n\n    try {\n      let newDecorationId = textModel.deltaDecorations([], [{\n        range: currentRange,\n        options: {\n          inlineClassName: `monaco__feedback--${data.type}`,\n          linesDecorationsClassName: `monaco__line monaco__line--${data.type}`,\n          stickiness: window.monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n        }\n      }])[0];\n      this.decorationsMap[newDecorationId] = data;\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  editor.unDecorate = function unDecorate(decorationId) {\n    let textModel = this.getModel();\n    let currentDecorations = Object.keys(this.decorationsMap).filter(id => id !== decorationId).map(id => ({\n      range: textModel.getDecorationRange(id),\n      data: this.decorationsMap[id]\n    }));\n    textModel.deltaDecorations(Object.keys(this.decorationsMap), []);\n    this.decorationsMap = {};\n    currentDecorations.forEach(decoration => this.decorate(decoration.data, decoration.range));\n  };\n\n  editor.getEmptyDecorations = function getEmptyDecorations() {\n    let textModel = this.getModel();\n    return Object.keys(this.decorationsMap).filter(id => textModel.getDecorationRange(id).isEmpty()).map(id => this.decorationsMap[id]);\n  };\n\n  editor.getCustomDecorations = function getCustomDecorations() {\n    const textModel = this.getModel();\n    let resp = {};\n    Object.keys(this.decorationsMap).forEach(id => {\n      resp[id] = {\n        data: this.decorationsMap[id],\n        range: textModel.getDecorationRange(id)\n      };\n    });\n    return resp;\n  };\n\n  editor.getBestTooltipPosition = function (line, column) {\n    return {\n      leftOffset: editor.getOffsetForColumn(line, column) + editor.getLayoutInfo().contentLeft,\n      topOffset: editor.getTopForLineNumber(line + 1) - editor.getScrollTop()\n    };\n  };\n}\n\nfunction extendWithHover(editor, onShowCb, onHideCb) {\n  let timeoutId;\n  editor.onMouseMove(e => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      onHideCb();\n      let textModel = editor.getModel();\n      let hoverRange = new window.monaco.Range(e.target.position.lineNumber, e.target.position.column, e.target.position.lineNumber, e.target.position.column);\n      let foundMatch = Object.keys(editor.decorationsMap).some(id => {\n        if (window.monaco.Range.areIntersectingOrTouching(textModel.getDecorationRange(id), hoverRange)) {\n          onShowCb(editor.decorationsMap[id], {\n            topOffset: e.event.posy - e.event.editorPos.y,\n            leftOffset: e.event.posx - e.event.editorPos.x\n          });\n          editor.updateOptions({\n            hover: {\n              enabled: false\n            }\n          });\n          return true;\n        }\n\n        return false;\n      });\n\n      if (!foundMatch) {\n        editor.updateOptions({\n          hover: {\n            enabled: true\n          }\n        });\n      }\n    }, 500);\n  });\n  editor.onMouseLeave(e => {\n    clearTimeout(timeoutId);\n    onHideCb();\n  });\n}\n\nlet cursorTimeoutId;\n\nfunction extendWithCursorSelectionTooltip(editor, onShowCb, onHideCb) {\n  editor.onDidChangeCursorSelection(({\n    selection\n  }) => {\n    clearTimeout(cursorTimeoutId);\n    onChangeCursorSelection.call(editor, selection, onShowCb, onHideCb);\n  });\n}\n\nfunction onChangeCursorSelection(selection, onShowCb, onHideCb) {\n  onHideCb();\n\n  if (selection.isEmpty()) {\n    return;\n  }\n\n  cursorTimeoutId = setTimeout(() => {\n    onShowCb(_objectSpread({\n      tooltipVisible: true\n    }, getTooltipPosition(selection, this)), selection);\n  }, 1000);\n}\n\nfunction formatCode(editor) {// FIXME\n}\n\nconst {\n  create,\n  setModelLanguage\n} = window.monaco.editor;\nconst {\n  Range\n} = window.monaco;\nexport { create, setModelLanguage, Range, extendWithDecorate, extendWithHover, extendWithCursorSelectionTooltip, formatCode };\n/**\r\n *\r\n * @param {window.monaco.Range} range\r\n */\n\nfunction getTooltipPosition(range, editor) {\n  // Left\n  let leftOffset = 64;\n\n  if (range.startColumn > range.endColumn) {\n    [range.startColumn, range.endColumn] = [range.endColumn, range.startColumn];\n    leftOffset += (range.endColumn - range.startColumn) * LETTER_WIDTH;\n  }\n\n  if (editor.getOffsetForColumn(range.startLineNumber, range.startColumn) < editor.getScrollLeft()) {\n    range.startColumn = Math.floor(editor.getScrollLeft() / LETTER_WIDTH);\n  }\n\n  if (editor.getOffsetForColumn(range.endLineNumber, range.endColumn) > editor.getLayoutInfo().width) {\n    range.endColumn = Math.floor(range.startColumn + editor.getLayoutInfo().width / LETTER_WIDTH);\n  }\n\n  let middleColumn = Math.floor(range.startColumn + (range.endColumn - range.startColumn) / 2);\n  leftOffset += editor.getOffsetForColumn(range.startLineNumber, middleColumn) - editor.getScrollLeft(); // Top\n\n  if (range.startLineNumber > range.endLineNumber) {\n    [range.startLineNumber, range.endLineNumber] = [range.endLineNumber, range.startLineNumber];\n  }\n\n  let topOffset = 0;\n\n  if (editor.getTopForLineNumber(range.startLineNumber) > editor.getScrollTop()) {\n    topOffset += editor.getTopForLineNumber(range.startLineNumber) - editor.getScrollTop();\n  }\n\n  return {\n    topOffset,\n    leftOffset\n  };\n}","map":{"version":3,"sources":["C:/Users/didi/Desktop/frontend.ro/client/components/Editor/monaco.ts"],"names":["FEEDBACK_TYPES","LETTER_WIDTH","extendWithDecorate","editor","decorationsMap","decorate","data","args","currentRange","window","monaco","Range","type","PRAISE","length","textModel","getModel","Object","keys","map","id","getDecorationRange","find","rangeInfo","areIntersecting","newDecorationId","deltaDecorations","range","options","inlineClassName","linesDecorationsClassName","stickiness","TrackedRangeStickiness","NeverGrowsWhenTypingAtEdges","err","console","log","unDecorate","decorationId","currentDecorations","filter","forEach","decoration","getEmptyDecorations","isEmpty","getCustomDecorations","resp","getBestTooltipPosition","line","column","leftOffset","getOffsetForColumn","getLayoutInfo","contentLeft","topOffset","getTopForLineNumber","getScrollTop","extendWithHover","onShowCb","onHideCb","timeoutId","onMouseMove","e","clearTimeout","setTimeout","hoverRange","target","position","lineNumber","foundMatch","some","areIntersectingOrTouching","event","posy","editorPos","y","posx","x","updateOptions","hover","enabled","onMouseLeave","cursorTimeoutId","extendWithCursorSelectionTooltip","onDidChangeCursorSelection","selection","onChangeCursorSelection","call","tooltipVisible","getTooltipPosition","formatCode","create","setModelLanguage","startColumn","endColumn","startLineNumber","getScrollLeft","Math","floor","endLineNumber","width","middleColumn"],"mappings":"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","sourcesContent":["/* eslint-disable vars-on-top */\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-var */\r\n\r\nimport { FEEDBACK_TYPES } from '~/services/Constants';\r\n\r\ndeclare global {\r\n  var monaco: any;\r\n}\r\n\r\n// import './monaco.scss';\r\n\r\nconst LETTER_WIDTH = 7.75;\r\n\r\nfunction extendWithDecorate(editor) {\r\n  editor.decorationsMap = {};\r\n\r\n  editor.decorate = function decorate(data, ...args) {\r\n    let currentRange = new window.monaco.Range(...args);\r\n    data.type = data.type || FEEDBACK_TYPES.PRAISE;\r\n\r\n    if (args.length === 1 && args[0] instanceof window.monaco.Range) {\r\n      [currentRange] = args;\r\n    }\r\n\r\n    let textModel = this.getModel();\r\n    if (\r\n      Object.keys(this.decorationsMap)\r\n        .map((id) => textModel.getDecorationRange(id))\r\n        .find((rangeInfo) => window.monaco.Range.areIntersecting(rangeInfo, currentRange))\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      let newDecorationId = textModel.deltaDecorations(\r\n        [],\r\n        [\r\n          {\r\n            range: currentRange,\r\n            options: {\r\n              inlineClassName: `monaco__feedback--${data.type}`,\r\n              linesDecorationsClassName: `monaco__line monaco__line--${data.type}`,\r\n              stickiness:\r\n                window.monaco.editor.TrackedRangeStickiness\r\n                  .NeverGrowsWhenTypingAtEdges,\r\n            },\r\n          },\r\n        ],\r\n      )[0];\r\n\r\n      this.decorationsMap[newDecorationId] = data;\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  };\r\n\r\n  editor.unDecorate = function unDecorate(decorationId) {\r\n    let textModel = this.getModel();\r\n\r\n    let currentDecorations = Object.keys(this.decorationsMap)\r\n      .filter((id) => id !== decorationId)\r\n      .map((id) => ({\r\n        range: textModel.getDecorationRange(id),\r\n        data: this.decorationsMap[id],\r\n      }));\r\n\r\n    textModel.deltaDecorations(Object.keys(this.decorationsMap), []);\r\n\r\n    this.decorationsMap = {};\r\n\r\n    currentDecorations.forEach((decoration) => this.decorate(decoration.data, decoration.range));\r\n  };\r\n\r\n  editor.getEmptyDecorations = function getEmptyDecorations() {\r\n    let textModel = this.getModel();\r\n\r\n    return Object.keys(this.decorationsMap)\r\n      .filter((id) => textModel.getDecorationRange(id).isEmpty())\r\n      .map((id) => this.decorationsMap[id]);\r\n  };\r\n\r\n  editor.getCustomDecorations = function getCustomDecorations() {\r\n    const textModel = this.getModel();\r\n    let resp = {};\r\n\r\n    Object.keys(this.decorationsMap).forEach((id) => {\r\n      resp[id] = {\r\n        data: this.decorationsMap[id],\r\n        range: textModel.getDecorationRange(id),\r\n      };\r\n    });\r\n\r\n    return resp;\r\n  };\r\n\r\n  editor.getBestTooltipPosition = function (line, column) {\r\n    return {\r\n      leftOffset:\r\n        editor.getOffsetForColumn(line, column)\r\n        + editor.getLayoutInfo().contentLeft,\r\n      topOffset: editor.getTopForLineNumber(line + 1) - editor.getScrollTop(),\r\n    };\r\n  };\r\n}\r\n\r\nfunction extendWithHover(editor, onShowCb, onHideCb) {\r\n  let timeoutId;\r\n\r\n  editor.onMouseMove((e) => {\r\n    clearTimeout(timeoutId);\r\n\r\n    timeoutId = setTimeout(() => {\r\n      onHideCb();\r\n\r\n      let textModel = editor.getModel();\r\n      let hoverRange = new window.monaco.Range(\r\n        e.target.position.lineNumber,\r\n        e.target.position.column,\r\n        e.target.position.lineNumber,\r\n        e.target.position.column,\r\n      );\r\n\r\n      let foundMatch = Object.keys(editor.decorationsMap).some((id) => {\r\n        if (\r\n          window.monaco.Range.areIntersectingOrTouching(\r\n            textModel.getDecorationRange(id),\r\n            hoverRange,\r\n          )\r\n        ) {\r\n          onShowCb(editor.decorationsMap[id], {\r\n            topOffset: e.event.posy - e.event.editorPos.y,\r\n            leftOffset: e.event.posx - e.event.editorPos.x,\r\n          });\r\n\r\n          editor.updateOptions({\r\n            hover: {\r\n              enabled: false,\r\n            },\r\n          });\r\n\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      });\r\n\r\n      if (!foundMatch) {\r\n        editor.updateOptions({\r\n          hover: {\r\n            enabled: true,\r\n          },\r\n        });\r\n      }\r\n    }, 500);\r\n  });\r\n\r\n  editor.onMouseLeave((e) => {\r\n    clearTimeout(timeoutId);\r\n    onHideCb();\r\n  });\r\n}\r\n\r\nlet cursorTimeoutId;\r\n\r\nfunction extendWithCursorSelectionTooltip(editor, onShowCb, onHideCb) {\r\n  editor.onDidChangeCursorSelection(({ selection }) => {\r\n    clearTimeout(cursorTimeoutId);\r\n    onChangeCursorSelection.call(editor, selection, onShowCb, onHideCb);\r\n  });\r\n}\r\n\r\nfunction onChangeCursorSelection(selection, onShowCb, onHideCb) {\r\n  onHideCb();\r\n\r\n  if (selection.isEmpty()) {\r\n    return;\r\n  }\r\n\r\n  cursorTimeoutId = setTimeout(() => {\r\n    onShowCb(\r\n      {\r\n        tooltipVisible: true,\r\n        ...getTooltipPosition(selection, this),\r\n      },\r\n      selection,\r\n    );\r\n  }, 1000);\r\n}\r\n\r\nfunction formatCode(editor) {\r\n  // FIXME\r\n}\r\n\r\nconst { create, setModelLanguage } = window.monaco.editor;\r\nconst { Range } = window.monaco;\r\n\r\nexport {\r\n  create,\r\n  setModelLanguage,\r\n  Range,\r\n  extendWithDecorate,\r\n  extendWithHover,\r\n  extendWithCursorSelectionTooltip,\r\n  formatCode,\r\n};\r\n\r\n/**\r\n *\r\n * @param {window.monaco.Range} range\r\n */\r\nfunction getTooltipPosition(range, editor) {\r\n  // Left\r\n  let leftOffset = 64;\r\n  if (range.startColumn > range.endColumn) {\r\n    [range.startColumn, range.endColumn] = [range.endColumn, range.startColumn];\r\n\r\n    leftOffset += (range.endColumn - range.startColumn) * LETTER_WIDTH;\r\n  }\r\n\r\n  if (\r\n    editor.getOffsetForColumn(range.startLineNumber, range.startColumn)\r\n    < editor.getScrollLeft()\r\n  ) {\r\n    range.startColumn = Math.floor(editor.getScrollLeft() / LETTER_WIDTH);\r\n  }\r\n\r\n  if (\r\n    editor.getOffsetForColumn(range.endLineNumber, range.endColumn)\r\n    > editor.getLayoutInfo().width\r\n  ) {\r\n    range.endColumn = Math.floor(\r\n      range.startColumn + editor.getLayoutInfo().width / LETTER_WIDTH,\r\n    );\r\n  }\r\n\r\n  let middleColumn = Math.floor(\r\n    range.startColumn + (range.endColumn - range.startColumn) / 2,\r\n  );\r\n  leftOffset\r\n    += editor.getOffsetForColumn(range.startLineNumber, middleColumn)\r\n    - editor.getScrollLeft();\r\n\r\n  // Top\r\n  if (range.startLineNumber > range.endLineNumber) {\r\n    [range.startLineNumber, range.endLineNumber] = [\r\n      range.endLineNumber,\r\n      range.startLineNumber,\r\n    ];\r\n  }\r\n\r\n  let topOffset = 0;\r\n  if (\r\n    editor.getTopForLineNumber(range.startLineNumber) > editor.getScrollTop()\r\n  ) {\r\n    topOffset\r\n      += editor.getTopForLineNumber(range.startLineNumber) - editor.getScrollTop();\r\n  }\r\n\r\n  return {\r\n    topOffset,\r\n    leftOffset,\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}