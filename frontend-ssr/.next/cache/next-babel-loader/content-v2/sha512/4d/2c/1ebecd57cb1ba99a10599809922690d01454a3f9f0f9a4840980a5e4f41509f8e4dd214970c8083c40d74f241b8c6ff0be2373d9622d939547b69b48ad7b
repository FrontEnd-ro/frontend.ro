{"ast":null,"code":"import mongoose, { isValidObjectId } from 'mongoose';\nimport { ServerError } from './ServerUtils';\nexport function connectToDb() {\n  var _mongoose$connection;\n\n  if (((_mongoose$connection = mongoose.connection) === null || _mongoose$connection === void 0 ? void 0 : _mongoose$connection.readyState) === 1) {\n    /** Early return - already connected */\n    return Promise.resolve(mongoose);\n  }\n\n  return mongoose.connect(process.env.DB_CONNECT, {\n    poolSize: 1,\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    useFindAndModify: false,\n    useCreateIndex: true\n  });\n}\n/** Extract the first human-readable error message from a Mongoose ValidationError */\n\nexport function extractDbErrorMessage(err) {\n  if (err.errors) {\n    var keys = Object.keys(err.errors);\n    var firstKeyWithErrorMessage = keys.find(function (key) {\n      return err.errors[key].message;\n    });\n\n    if (firstKeyWithErrorMessage) {\n      return err.errors[firstKeyWithErrorMessage].message;\n    }\n  }\n\n  return err._message || 'Oops, something went wrong...';\n}\n/** Verify that payload doesn't have extra props not present on the Schema */\n\nexport function validateAgainstSchemaProps(payload, Schema) {\n  var keys = Object.keys(payload); // eslint-disable-next-line no-restricted-syntax\n\n  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n    var key = _keys[_i];\n\n    if (!(key in Schema.obj)) {\n      throw new ServerError(400, \"Property '\".concat(key, \"' cannot be directly set.\"));\n    }\n  }\n}\nexport function validateObjectid(_id) {\n  if (!isValidObjectId(_id)) {\n    throw new ServerError(400, \"Value '\".concat(_id, \"' is not a valid ObjectId identifier\"));\n  }\n}","map":{"version":3,"sources":["/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/server/database.ts"],"names":["mongoose","isValidObjectId","ServerError","connectToDb","connection","readyState","Promise","resolve","connect","process","env","DB_CONNECT","poolSize","useNewUrlParser","useUnifiedTopology","useFindAndModify","useCreateIndex","extractDbErrorMessage","err","errors","keys","Object","firstKeyWithErrorMessage","find","key","message","_message","validateAgainstSchemaProps","payload","Schema","obj","validateObjectid","_id"],"mappings":"AAAA,OAAOA,QAAP,IAAmBC,eAAnB,QAA0C,UAA1C;AACA,SAASC,WAAT,QAA4B,eAA5B;AAEA,OAAO,SAASC,WAAT,GAAuB;AAAA;;AAC5B,MAAI,yBAAAH,QAAQ,CAACI,UAAT,8EAAqBC,UAArB,MAAoC,CAAxC,EAA2C;AACzC;AACA,WAAOC,OAAO,CAACC,OAAR,CAAgBP,QAAhB,CAAP;AACD;;AAED,SAAOA,QAAQ,CAACQ,OAAT,CAAiBC,OAAO,CAACC,GAAR,CAAYC,UAA7B,EAAyC;AAC9CC,IAAAA,QAAQ,EAAE,CADoC;AAE9CC,IAAAA,eAAe,EAAE,IAF6B;AAG9CC,IAAAA,kBAAkB,EAAE,IAH0B;AAI9CC,IAAAA,gBAAgB,EAAE,KAJ4B;AAK9CC,IAAAA,cAAc,EAAE;AAL8B,GAAzC,CAAP;AAOD;AAED;;AACA,OAAO,SAASC,qBAAT,CAA+BC,GAA/B,EAAgF;AACrF,MAAIA,GAAG,CAACC,MAAR,EAAgB;AACd,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,GAAG,CAACC,MAAhB,CAAb;AACA,QAAMG,wBAAwB,GAAGF,IAAI,CAACG,IAAL,CAAU,UAACC,GAAD;AAAA,aAASN,GAAG,CAACC,MAAJ,CAAWK,GAAX,EAAgBC,OAAzB;AAAA,KAAV,CAAjC;;AAEA,QAAIH,wBAAJ,EAA8B;AAC5B,aAAOJ,GAAG,CAACC,MAAJ,CAAWG,wBAAX,EAAqCG,OAA5C;AACD;AACF;;AAED,SAAOP,GAAG,CAACQ,QAAJ,IAAgB,+BAAvB;AACD;AAED;;AACA,OAAO,SAASC,0BAAT,CAAoCC,OAApC,EAA6CC,MAA7C,EAAsE;AAC3E,MAAMT,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYQ,OAAZ,CAAb,CAD2E,CAG3E;;AACA,2BAAkBR,IAAlB,2BAAwB;AAAnB,QAAMI,GAAG,YAAT;;AACH,QAAI,EAAEA,GAAG,IAAIK,MAAM,CAACC,GAAhB,CAAJ,EAA0B;AACxB,YAAM,IAAI5B,WAAJ,CAAgB,GAAhB,sBAAkCsB,GAAlC,+BAAN;AACD;AACF;AACF;AAED,OAAO,SAASO,gBAAT,CAA0BC,GAA1B,EAAuC;AAC5C,MAAI,CAAC/B,eAAe,CAAC+B,GAAD,CAApB,EAA2B;AACzB,UAAM,IAAI9B,WAAJ,CAAgB,GAAhB,mBAA+B8B,GAA/B,0CAAN;AACD;AACF","sourcesContent":["import mongoose, { isValidObjectId } from 'mongoose';\nimport { ServerError } from './ServerUtils';\n\nexport function connectToDb() {\n  if (mongoose.connection?.readyState === 1) {\n    /** Early return - already connected */\n    return Promise.resolve(mongoose);\n  }\n\n  return mongoose.connect(process.env.DB_CONNECT, {\n    poolSize: 1,\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    useFindAndModify: false,\n    useCreateIndex: true,\n  });\n}\n\n/** Extract the first human-readable error message from a Mongoose ValidationError */\nexport function extractDbErrorMessage(err: { errors?: any, _message?: string}) :string {\n  if (err.errors) {\n    const keys = Object.keys(err.errors);\n    const firstKeyWithErrorMessage = keys.find((key) => err.errors[key].message);\n\n    if (firstKeyWithErrorMessage) {\n      return err.errors[firstKeyWithErrorMessage].message;\n    }\n  }\n\n  return err._message || 'Oops, something went wrong...';\n}\n\n/** Verify that payload doesn't have extra props not present on the Schema */\nexport function validateAgainstSchemaProps(payload, Schema: mongoose.Schema) {\n  const keys = Object.keys(payload);\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key of keys) {\n    if (!(key in Schema.obj)) {\n      throw new ServerError(400, `Property '${key}' cannot be directly set.`);\n    }\n  }\n}\n\nexport function validateObjectid(_id: string) {\n  if (!isValidObjectId(_id)) {\n    throw new ServerError(400, `Value '${_id}' is not a valid ObjectId identifier`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}