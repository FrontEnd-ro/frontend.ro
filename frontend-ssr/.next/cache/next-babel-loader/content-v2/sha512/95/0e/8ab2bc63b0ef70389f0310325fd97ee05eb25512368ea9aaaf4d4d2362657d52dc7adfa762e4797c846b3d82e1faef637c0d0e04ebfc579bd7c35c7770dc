{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar _mongoose$models;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport mongoose from 'mongoose';\nimport uniqueValidator from 'mongoose-unique-validator';\nimport jwt from 'jsonwebtoken';\nimport { validateAgainstSchemaProps } from '../database';\nimport { AUTH_EXPIRATION, ServerError } from '../ServerUtils';\nvar UsersSchema = new mongoose.Schema({\n  avatar: {\n    type: String,\n    required: true\n  },\n  name: {\n    type: String,\n    required: false,\n    \"default\": ''\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  username: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  password: {\n    type: String,\n    required: true\n  },\n  lastLogin: {\n    type: Date,\n    \"default\": Date.now()\n  }\n});\nUsersSchema.plugin(uniqueValidator);\nvar User = ((_mongoose$models = mongoose.models) === null || _mongoose$models === void 0 ? void 0 : _mongoose$models.User) || mongoose.model('User', UsersSchema);\n\nvar UserModel = /*#__PURE__*/function () {\n  function UserModel() {\n    _classCallCheck(this, UserModel);\n  }\n\n  _createClass(UserModel, null, [{\n    key: \"search\",\n    value: function search() {\n      return User.find({});\n    }\n  }, {\n    key: \"ping\",\n    value: function () {\n      var _ping = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(token) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  jwt.verify(token, process.env.TOKEN_SECRET, /*#__PURE__*/function () {\n                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(err, decodedInfo) {\n                      var _id, user;\n\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              if (!err) {\n                                _context.next = 3;\n                                break;\n                              }\n\n                              reject(new ServerError(401, 'Not authenticated'));\n                              return _context.abrupt(\"return\");\n\n                            case 3:\n                              _id = decodedInfo._id;\n                              _context.next = 6;\n                              return UserModel.findUserBy({\n                                _id: _id\n                              });\n\n                            case 6:\n                              user = _context.sent;\n\n                              if (user) {\n                                _context.next = 10;\n                                break;\n                              }\n\n                              reject(new ServerError(404, \"User doesn't exist anymore!\"));\n                              return _context.abrupt(\"return\");\n\n                            case 10:\n                              resolve(user);\n\n                            case 11:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function (_x2, _x3) {\n                      return _ref.apply(this, arguments);\n                    };\n                  }());\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function ping(_x) {\n        return _ping.apply(this, arguments);\n      }\n\n      return ping;\n    }()\n  }, {\n    key: \"create\",\n    value: function create(payload) {\n      validateAgainstSchemaProps(payload, UsersSchema);\n      var user = new User(payload);\n      return new Promise(function (resolve, reject) {\n        user.save(function (err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          resolve(user);\n        });\n      });\n    }\n  }, {\n    key: \"findUserBy\",\n    value: function () {\n      var _findUserBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(filters) {\n        var user;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return User.findOne(filters);\n\n              case 2:\n                user = _context3.sent;\n                return _context3.abrupt(\"return\", user || null);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function findUserBy(_x4) {\n        return _findUserBy.apply(this, arguments);\n      }\n\n      return findUserBy;\n    }()\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _getUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref2) {\n        var username, email, user;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                username = _ref2.username, email = _ref2.email;\n                _context4.next = 3;\n                return User.findOne({\n                  $or: [{\n                    username: username\n                  }, {\n                    email: email\n                  }]\n                });\n\n              case 3:\n                user = _context4.sent;\n                return _context4.abrupt(\"return\", user || null);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function getUser(_x5) {\n        return _getUser.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n  }, {\n    key: \"generateJwtForUser\",\n    value: function generateJwtForUser(_id) {\n      return jwt.sign({\n        _id: _id\n      }, process.env.TOKEN_SECRET, {\n        expiresIn: \"\".concat(AUTH_EXPIRATION, \"d\"),\n        algorithm: process.env.TOKEN_ALGORITHM\n      });\n    }\n  }, {\n    key: \"sanitize\",\n    value: function sanitize(user) {\n      var sanitizedUser = _objectSpread({}, user.toObject());\n\n      var propsToDelete = ['_id', '__v'];\n      propsToDelete.forEach(function (prop) {\n        return delete sanitizedUser[prop];\n      });\n      return sanitizedUser;\n    }\n  }]);\n\n  return UserModel;\n}();\n\nexport default UserModel;","map":{"version":3,"sources":["/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/server/model/user.model.ts"],"names":["mongoose","uniqueValidator","jwt","validateAgainstSchemaProps","AUTH_EXPIRATION","ServerError","UsersSchema","Schema","avatar","type","String","required","name","email","unique","username","password","lastLogin","Date","now","plugin","User","models","model","UserModel","find","token","Promise","resolve","reject","verify","process","env","TOKEN_SECRET","err","decodedInfo","_id","findUserBy","user","payload","save","filters","findOne","$or","sign","expiresIn","algorithm","TOKEN_ALGORITHM","sanitizedUser","toObject","propsToDelete","forEach","prop"],"mappings":"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","sourcesContent":["import mongoose, { Document } from 'mongoose';\nimport uniqueValidator from 'mongoose-unique-validator';\nimport jwt, { SignOptions } from 'jsonwebtoken';\nimport { validateAgainstSchemaProps } from '../database';\nimport { AUTH_EXPIRATION, ServerError } from '../ServerUtils';\n\nconst UsersSchema = new mongoose.Schema({\n  avatar: { type: String, required: true },\n  name: { type: String, required: false, default: '' },\n  email: { type: String, required: true, unique: true },\n  username: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n  lastLogin: { type: Date, default: Date.now() },\n});\nUsersSchema.plugin(uniqueValidator);\n\nconst User = mongoose.models?.User || mongoose.model('User', UsersSchema);\n\nexport interface EncodedData {\n  _id: string\n}\n\nclass UserModel {\n  static search() {\n    return User.find({});\n  }\n\n  static async ping(token: string) : Promise<Document> {\n    return new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.TOKEN_SECRET, async (err, decodedInfo: EncodedData) => {\n        if (err) {\n          reject(new ServerError(401, 'Not authenticated'));\n          return;\n        }\n\n        const { _id } = decodedInfo;\n\n        const user = await UserModel.findUserBy({ _id });\n        if (!user) {\n          reject(new ServerError(404, \"User doesn't exist anymore!\"));\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static create(payload): Promise<Document> {\n    validateAgainstSchemaProps(payload, UsersSchema);\n\n    const user: Document = new User(payload);\n\n    return new Promise((resolve, reject) => {\n      user.save((err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static async findUserBy(filters: { [id: string]: any }) {\n    const user = await User.findOne(filters);\n\n    return user || null;\n  }\n\n  static async getUser({\n    username,\n    email,\n  }: {\n    username: string;\n    email: string;\n  }) {\n    const user = await User.findOne({\n      $or: [{ username }, { email }],\n    });\n\n    return user || null;\n  }\n\n  static generateJwtForUser(_id: string) {\n    return jwt.sign(\n      { _id },\n      process.env.TOKEN_SECRET,\n      {\n        expiresIn: `${AUTH_EXPIRATION}d`,\n        algorithm: process.env.TOKEN_ALGORITHM as SignOptions['algorithm'],\n      },\n    );\n  }\n\n  static sanitize(user: Document) : any {\n    const sanitizedUser = { ...user.toObject() };\n    const propsToDelete = ['_id', '__v'];\n\n    propsToDelete.forEach((prop) => delete sanitizedUser[prop]);\n\n    return sanitizedUser;\n  }\n}\n\nexport default UserModel;\n"]},"metadata":{},"sourceType":"module"}