{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/components/TableOfContents/TableOfContents.tsx\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport styles from './TableOfContents.module.scss';\nvar SCROLL_DURATION = 2000;\n\nvar TableOfContents = /*#__PURE__*/function (_React$Component) {\n  _inherits(TableOfContents, _React$Component);\n\n  var _super = _createSuper(TableOfContents);\n\n  function TableOfContents(props) {\n    var _this;\n\n    _classCallCheck(this, TableOfContents);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"observer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"timeoutId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"observeAll\", function () {\n      var chapters = _this.props.chapters;\n      /**  Target the elements to be observed */\n\n      chapters.forEach(function (item) {\n        var chapterId = document.getElementById(item.id);\n\n        if (chapterId !== null) {\n          _this.observer.observe(chapterId);\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"changeNav\", function (entries) {\n      var activeChapterId = _this.state.activeChapterId;\n      entries.some(function (entry) {\n        if (entry.intersectionRatio <= 0.5) {\n          return false;\n        }\n\n        if (entry.target.id !== activeChapterId) {\n          /**\n           * Using the NextRouter `replace` method is buggy on Firefox, triggering\n           * a scroll when it intersects an element.\n           *\n           * This is reproducing only when using a Mouse, not the touchpad on laptop.\n           */\n          window.history.replaceState(null, '', \"\".concat(window.location.pathname, \"#\").concat(entry.target.id));\n\n          _this.setState({\n            activeChapterId: entry.target.id\n          });\n        }\n\n        return true;\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollToItem\", function (id) {\n      var onChapterClick = _this.props.onChapterClick;\n      var itemToScroll = document.getElementById(id);\n\n      if (itemToScroll === null) {\n        console.warn(\"TableOfContents: expected to find element with id=\".concat(id, \" to scroll to\"));\n      }\n      /**\n       * Clickin on a link scrolls to that element.\n       * However, since we already have an active InsersectionObserver we may\n       * get racing conditions which mess up the correctly highlighted/scrolled element.\n       *\n       * To fix this we're disabling the observer while the scroll is in progress,\n       * and then re'attaching it. A proper solution would need us to know when\n       * the scroll has ended. We could add a `scroll` event on document but that\n       * wouldn't work if the article is rendered in just a part of the page.\n       *\n       * So, our solution was to \"guess\" how long it would take to scroll, and use a timeout.\n       */\n\n\n      _this.observer.disconnect();\n\n      clearTimeout(_this.timeoutId);\n      _this.timeoutId = setTimeout(_this.observeAll, SCROLL_DURATION);\n\n      _this.setState({\n        activeChapterId: id\n      });\n\n      onChapterClick(id);\n    });\n\n    _this.state = {\n      activeChapterId: props.chapters[0].id\n    };\n    return _this;\n  }\n\n  _createClass(TableOfContents, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var options = {\n        threshold: 0.5\n      };\n\n      if (window.location.hash) {\n        this.setState({\n          activeChapterId: window.location.hash.split('#')[1]\n        });\n      }\n\n      this.observer = new IntersectionObserver(this.changeNav, options);\n      this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.observer.disconnect();\n      clearTimeout(this.timeoutId);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var chapters = this.props.chapters;\n      var activeChapterId = this.state.activeChapterId;\n      return __jsx(\"nav\", {\n        className: styles.tableOfContents,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 7\n        }\n      }, __jsx(\"ul\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 9\n        }\n      }, chapters.map(function (item) {\n        return __jsx(\"li\", {\n          key: item.id,\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 129,\n            columnNumber: 13\n          }\n        }, __jsx(\"a\", {\n          href: \"#\".concat(item.id),\n          onClick: function onClick() {\n            return _this2.scrollToItem(item.id);\n          },\n          className: activeChapterId === item.id ? \"\".concat(styles.active, \" text-bold\") : 'text-bold',\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 132,\n            columnNumber: 15\n          }\n        }, item.title));\n      })));\n    }\n  }]);\n\n  return TableOfContents;\n}(React.Component);\n\nexport default TableOfContents;","map":{"version":3,"sources":["/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/components/TableOfContents/TableOfContents.tsx"],"names":["React","styles","SCROLL_DURATION","TableOfContents","props","chapters","forEach","item","chapterId","document","getElementById","id","observer","observe","entries","activeChapterId","state","some","entry","intersectionRatio","target","window","history","replaceState","location","pathname","setState","onChapterClick","itemToScroll","console","warn","disconnect","clearTimeout","timeoutId","setTimeout","observeAll","options","threshold","hash","split","IntersectionObserver","changeNav","tableOfContents","map","scrollToItem","active","title","Component"],"mappings":"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","sourcesContent":["import React from 'react';\nimport styles from './TableOfContents.module.scss';\n\ninterface State {\n  activeChapterId: string;\n}\n\ninterface Props {\n  chapters: Chapter[];\n  onChapterClick?: (id: string) => void\n}\n\nexport interface Chapter {\n    title: string;\n    id: string;\n}\n\nconst SCROLL_DURATION = 2000;\n\nclass TableOfContents extends React.Component<Props, State> {\n  private observer: IntersectionObserver;\n\n  private timeoutId: any;\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      activeChapterId: props.chapters[0].id,\n    };\n  }\n\n  componentDidMount() {\n    const options = {\n      threshold: 0.5,\n    };\n\n    if (window.location.hash) {\n      this.setState({\n        activeChapterId: window.location.hash.split('#')[1],\n      });\n    }\n\n    this.observer = new IntersectionObserver(this.changeNav, options);\n    this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n    clearTimeout(this.timeoutId);\n  }\n\n  observeAll = () => {\n    const { chapters } = this.props;\n\n    /**  Target the elements to be observed */\n    chapters.forEach((item) => {\n      const chapterId = document.getElementById(item.id);\n      if (chapterId !== null) {\n        this.observer.observe(chapterId);\n      }\n    });\n  };\n\n  changeNav = (entries) => {\n    const { activeChapterId } = this.state;\n    entries.some((entry) => {\n      if (entry.intersectionRatio <= 0.5) {\n        return false;\n      }\n\n      if (entry.target.id !== activeChapterId) {\n        /**\n         * Using the NextRouter `replace` method is buggy on Firefox, triggering\n         * a scroll when it intersects an element.\n         *\n         * This is reproducing only when using a Mouse, not the touchpad on laptop.\n         */\n        window.history.replaceState(null, '', `${window.location.pathname}#${entry.target.id}`);\n\n        this.setState({\n          activeChapterId: entry.target.id,\n        });\n      }\n\n      return true;\n    });\n  }\n\n  scrollToItem = (id) => {\n    const { onChapterClick } = this.props;\n\n    let itemToScroll = document.getElementById(id);\n    if (itemToScroll === null) {\n      console.warn(`TableOfContents: expected to find element with id=${id} to scroll to`);\n    }\n\n    /**\n     * Clickin on a link scrolls to that element.\n     * However, since we already have an active InsersectionObserver we may\n     * get racing conditions which mess up the correctly highlighted/scrolled element.\n     *\n     * To fix this we're disabling the observer while the scroll is in progress,\n     * and then re'attaching it. A proper solution would need us to know when\n     * the scroll has ended. We could add a `scroll` event on document but that\n     * wouldn't work if the article is rendered in just a part of the page.\n     *\n     * So, our solution was to \"guess\" how long it would take to scroll, and use a timeout.\n     */\n    this.observer.disconnect();\n\n    clearTimeout(this.timeoutId);\n    this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n\n    this.setState({\n      activeChapterId: id,\n    });\n    onChapterClick(id);\n  }\n\n  render() {\n    const { chapters } = this.props;\n    const { activeChapterId } = this.state;\n\n    return (\n      <nav className={styles.tableOfContents}>\n        <ul>\n          {chapters.map((item) => (\n            <li\n              key={item.id}\n            >\n              <a\n                href={`#${item.id}`}\n                onClick={() => this.scrollToItem(item.id)}\n                className={activeChapterId === item.id ? `${styles.active} text-bold` : 'text-bold'}\n              >\n                {item.title}\n              </a>\n            </li>\n          ))}\n        </ul>\n      </nav>\n    );\n  }\n}\nexport default TableOfContents;\n"]},"metadata":{},"sourceType":"module"}