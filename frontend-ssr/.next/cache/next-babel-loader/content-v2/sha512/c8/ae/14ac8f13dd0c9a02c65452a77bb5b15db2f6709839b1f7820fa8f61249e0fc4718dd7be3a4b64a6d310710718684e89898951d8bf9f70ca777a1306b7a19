{"ast":null,"code":"var _jsxFileName = \"/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/components/TableOfContents/TableOfContents.tsx\";\nvar __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport styles from './TableOfContents.module.scss';\nconst SCROLL_DURATION = 2000;\n\nclass TableOfContents extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"observer\", void 0);\n\n    _defineProperty(this, \"timeoutId\", void 0);\n\n    _defineProperty(this, \"observeAll\", () => {\n      const {\n        chapters\n      } = this.props;\n      /**  Target the elements to be observed */\n\n      chapters.forEach(item => {\n        const chapterId = document.getElementById(item.id);\n\n        if (chapterId !== null) {\n          this.observer.observe(chapterId);\n        }\n      });\n    });\n\n    _defineProperty(this, \"changeNav\", entries => {\n      const {\n        activeChapterId\n      } = this.state;\n      entries.some(entry => {\n        if (entry.intersectionRatio <= 0.5) {\n          return false;\n        }\n\n        if (entry.target.id !== activeChapterId) {\n          /**\n           * Using the NextRouter `replace` method is buggy on Firefox, triggering\n           * a scroll when it intersects an element.\n           *\n           * This is reproducing only when using a Mouse, not the touchpad on laptop.\n           */\n          window.history.replaceState(null, '', `${window.location.pathname}#${entry.target.id}`);\n          this.setState({\n            activeChapterId: entry.target.id\n          });\n        }\n\n        return true;\n      });\n    });\n\n    _defineProperty(this, \"scrollToItem\", id => {\n      const {\n        onChapterClick\n      } = this.props;\n      let itemToScroll = document.getElementById(id);\n\n      if (itemToScroll === null) {\n        console.warn(`TableOfContents: expected to find element with id=${id} to scroll to`);\n      }\n      /**\n       * Clickin on a link scrolls to that element.\n       * However, since we already have an active InsersectionObserver we may\n       * get racing conditions which mess up the correctly highlighted/scrolled element.\n       *\n       * To fix this we're disabling the observer while the scroll is in progress,\n       * and then re'attaching it. A proper solution would need us to know when\n       * the scroll has ended. We could add a `scroll` event on document but that\n       * wouldn't work if the article is rendered in just a part of the page.\n       *\n       * So, our solution was to \"guess\" how long it would take to scroll, and use a timeout.\n       */\n\n\n      this.observer.disconnect();\n      clearTimeout(this.timeoutId);\n      this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n      this.setState({\n        activeChapterId: id\n      });\n      onChapterClick(id);\n    });\n\n    this.state = {\n      activeChapterId: props.chapters[0].id\n    };\n  }\n\n  componentDidMount() {\n    const options = {\n      threshold: 0.5\n    };\n\n    if (window.location.hash) {\n      this.setState({\n        activeChapterId: window.location.hash.split('#')[1]\n      });\n    }\n\n    this.observer = new IntersectionObserver(this.changeNav, options);\n    this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n    clearTimeout(this.timeoutId);\n  }\n\n  render() {\n    const {\n      chapters\n    } = this.props;\n    const {\n      activeChapterId\n    } = this.state;\n    return __jsx(\"nav\", {\n      className: styles.tableOfContents,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 7\n      }\n    }, __jsx(\"ul\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 127,\n        columnNumber: 9\n      }\n    }, chapters.map(item => __jsx(\"li\", {\n      key: item.id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129,\n        columnNumber: 13\n      }\n    }, __jsx(\"a\", {\n      href: `#${item.id}`,\n      onClick: () => this.scrollToItem(item.id),\n      className: activeChapterId === item.id ? `${styles.active} text-bold` : 'text-bold',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 132,\n        columnNumber: 15\n      }\n    }, item.title)))));\n  }\n\n}\n\nexport default TableOfContents;","map":{"version":3,"sources":["/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/components/TableOfContents/TableOfContents.tsx"],"names":["React","styles","SCROLL_DURATION","TableOfContents","Component","constructor","props","chapters","forEach","item","chapterId","document","getElementById","id","observer","observe","entries","activeChapterId","state","some","entry","intersectionRatio","target","window","history","replaceState","location","pathname","setState","onChapterClick","itemToScroll","console","warn","disconnect","clearTimeout","timeoutId","setTimeout","observeAll","componentDidMount","options","threshold","hash","split","IntersectionObserver","changeNav","componentWillUnmount","render","tableOfContents","map","scrollToItem","active","title"],"mappings":"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","sourcesContent":["import React from 'react';\nimport styles from './TableOfContents.module.scss';\n\ninterface State {\n  activeChapterId: string;\n}\n\ninterface Props {\n  chapters: Chapter[];\n  onChapterClick?: (id: string) => void\n}\n\nexport interface Chapter {\n    title: string;\n    id: string;\n}\n\nconst SCROLL_DURATION = 2000;\n\nclass TableOfContents extends React.Component<Props, State> {\n  private observer: IntersectionObserver;\n\n  private timeoutId: any;\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      activeChapterId: props.chapters[0].id,\n    };\n  }\n\n  componentDidMount() {\n    const options = {\n      threshold: 0.5,\n    };\n\n    if (window.location.hash) {\n      this.setState({\n        activeChapterId: window.location.hash.split('#')[1],\n      });\n    }\n\n    this.observer = new IntersectionObserver(this.changeNav, options);\n    this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n    clearTimeout(this.timeoutId);\n  }\n\n  observeAll = () => {\n    const { chapters } = this.props;\n\n    /**  Target the elements to be observed */\n    chapters.forEach((item) => {\n      const chapterId = document.getElementById(item.id);\n      if (chapterId !== null) {\n        this.observer.observe(chapterId);\n      }\n    });\n  };\n\n  changeNav = (entries) => {\n    const { activeChapterId } = this.state;\n    entries.some((entry) => {\n      if (entry.intersectionRatio <= 0.5) {\n        return false;\n      }\n\n      if (entry.target.id !== activeChapterId) {\n        /**\n         * Using the NextRouter `replace` method is buggy on Firefox, triggering\n         * a scroll when it intersects an element.\n         *\n         * This is reproducing only when using a Mouse, not the touchpad on laptop.\n         */\n        window.history.replaceState(null, '', `${window.location.pathname}#${entry.target.id}`);\n\n        this.setState({\n          activeChapterId: entry.target.id,\n        });\n      }\n\n      return true;\n    });\n  }\n\n  scrollToItem = (id) => {\n    const { onChapterClick } = this.props;\n\n    let itemToScroll = document.getElementById(id);\n    if (itemToScroll === null) {\n      console.warn(`TableOfContents: expected to find element with id=${id} to scroll to`);\n    }\n\n    /**\n     * Clickin on a link scrolls to that element.\n     * However, since we already have an active InsersectionObserver we may\n     * get racing conditions which mess up the correctly highlighted/scrolled element.\n     *\n     * To fix this we're disabling the observer while the scroll is in progress,\n     * and then re'attaching it. A proper solution would need us to know when\n     * the scroll has ended. We could add a `scroll` event on document but that\n     * wouldn't work if the article is rendered in just a part of the page.\n     *\n     * So, our solution was to \"guess\" how long it would take to scroll, and use a timeout.\n     */\n    this.observer.disconnect();\n\n    clearTimeout(this.timeoutId);\n    this.timeoutId = setTimeout(this.observeAll, SCROLL_DURATION);\n\n    this.setState({\n      activeChapterId: id,\n    });\n    onChapterClick(id);\n  }\n\n  render() {\n    const { chapters } = this.props;\n    const { activeChapterId } = this.state;\n\n    return (\n      <nav className={styles.tableOfContents}>\n        <ul>\n          {chapters.map((item) => (\n            <li\n              key={item.id}\n            >\n              <a\n                href={`#${item.id}`}\n                onClick={() => this.scrollToItem(item.id)}\n                className={activeChapterId === item.id ? `${styles.active} text-bold` : 'text-bold'}\n              >\n                {item.title}\n              </a>\n            </li>\n          ))}\n        </ul>\n      </nav>\n    );\n  }\n}\nexport default TableOfContents;\n"]},"metadata":{},"sourceType":"module"}