{"ast":null,"code":"var _mongoose$models;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport mongoose from 'mongoose';\nimport uniqueValidator from 'mongoose-unique-validator';\nimport jwt from 'jsonwebtoken';\nimport { validateAgainstSchemaProps } from '../database';\nimport { AUTH_EXPIRATION, ServerError } from '../ServerUtils';\nconst UsersSchema = new mongoose.Schema({\n  avatar: {\n    type: String,\n    required: true\n  },\n  name: {\n    type: String,\n    required: false,\n    default: ''\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  username: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  password: {\n    type: String,\n    required: true\n  },\n  lastLogin: {\n    type: Date,\n    default: Date.now()\n  }\n});\nUsersSchema.plugin(uniqueValidator);\nconst User = ((_mongoose$models = mongoose.models) === null || _mongoose$models === void 0 ? void 0 : _mongoose$models.User) || mongoose.model('User', UsersSchema);\n\nclass UserModel {\n  static search() {\n    return User.find({});\n  }\n\n  static async ping(token) {\n    return new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.TOKEN_SECRET, async (err, decodedInfo) => {\n        if (err) {\n          reject(new ServerError(401, 'Not authenticated'));\n          return;\n        }\n\n        const {\n          _id\n        } = decodedInfo;\n        const user = await UserModel.findUserBy({\n          _id\n        });\n\n        if (!user) {\n          reject(new ServerError(404, \"User doesn't exist anymore!\"));\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static create(payload) {\n    validateAgainstSchemaProps(payload, UsersSchema);\n    const user = new User(payload);\n    return new Promise((resolve, reject) => {\n      user.save(err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static async findUserBy(filters) {\n    const user = await User.findOne(filters);\n    return user || null;\n  }\n\n  static async getUser({\n    username,\n    email\n  }) {\n    const user = await User.findOne({\n      $or: [{\n        username\n      }, {\n        email\n      }]\n    });\n    return user || null;\n  }\n\n  static generateJwtForUser(_id) {\n    return jwt.sign({\n      _id\n    }, process.env.TOKEN_SECRET, {\n      expiresIn: `${AUTH_EXPIRATION}d`,\n      algorithm: process.env.TOKEN_ALGORITHM\n    });\n  }\n\n  static sanitize(user) {\n    const sanitizedUser = _objectSpread({}, user.toObject());\n\n    const propsToDelete = ['_id', '__v'];\n    propsToDelete.forEach(prop => delete sanitizedUser[prop]);\n    return sanitizedUser;\n  }\n\n}\n\nexport default UserModel;","map":{"version":3,"sources":["/Users/nmaties/Projects/personal/frontend.ro/frontend-ssr/server/model/user.model.ts"],"names":["mongoose","uniqueValidator","jwt","validateAgainstSchemaProps","AUTH_EXPIRATION","ServerError","UsersSchema","Schema","avatar","type","String","required","name","default","email","unique","username","password","lastLogin","Date","now","plugin","User","models","model","UserModel","search","find","ping","token","Promise","resolve","reject","verify","process","env","TOKEN_SECRET","err","decodedInfo","_id","user","findUserBy","create","payload","save","filters","findOne","getUser","$or","generateJwtForUser","sign","expiresIn","algorithm","TOKEN_ALGORITHM","sanitize","sanitizedUser","toObject","propsToDelete","forEach","prop"],"mappings":"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","sourcesContent":["import mongoose, { Document } from 'mongoose';\nimport uniqueValidator from 'mongoose-unique-validator';\nimport jwt, { SignOptions } from 'jsonwebtoken';\nimport { validateAgainstSchemaProps } from '../database';\nimport { AUTH_EXPIRATION, ServerError } from '../ServerUtils';\n\nconst UsersSchema = new mongoose.Schema({\n  avatar: { type: String, required: true },\n  name: { type: String, required: false, default: '' },\n  email: { type: String, required: true, unique: true },\n  username: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n  lastLogin: { type: Date, default: Date.now() },\n});\nUsersSchema.plugin(uniqueValidator);\n\nconst User = mongoose.models?.User || mongoose.model('User', UsersSchema);\n\nexport interface EncodedData {\n  _id: string\n}\n\nclass UserModel {\n  static search() {\n    return User.find({});\n  }\n\n  static async ping(token: string) : Promise<Document> {\n    return new Promise((resolve, reject) => {\n      jwt.verify(token, process.env.TOKEN_SECRET, async (err, decodedInfo: EncodedData) => {\n        if (err) {\n          reject(new ServerError(401, 'Not authenticated'));\n          return;\n        }\n\n        const { _id } = decodedInfo;\n\n        const user = await UserModel.findUserBy({ _id });\n        if (!user) {\n          reject(new ServerError(404, \"User doesn't exist anymore!\"));\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static create(payload): Promise<Document> {\n    validateAgainstSchemaProps(payload, UsersSchema);\n\n    const user: Document = new User(payload);\n\n    return new Promise((resolve, reject) => {\n      user.save((err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(user);\n      });\n    });\n  }\n\n  static async findUserBy(filters: { [id: string]: any }) {\n    const user = await User.findOne(filters);\n\n    return user || null;\n  }\n\n  static async getUser({\n    username,\n    email,\n  }: {\n    username: string;\n    email: string;\n  }) {\n    const user = await User.findOne({\n      $or: [{ username }, { email }],\n    });\n\n    return user || null;\n  }\n\n  static generateJwtForUser(_id: string) {\n    return jwt.sign(\n      { _id },\n      process.env.TOKEN_SECRET,\n      {\n        expiresIn: `${AUTH_EXPIRATION}d`,\n        algorithm: process.env.TOKEN_ALGORITHM as SignOptions['algorithm'],\n      },\n    );\n  }\n\n  static sanitize(user: Document) : any {\n    const sanitizedUser = { ...user.toObject() };\n    const propsToDelete = ['_id', '__v'];\n\n    propsToDelete.forEach((prop) => delete sanitizedUser[prop]);\n\n    return sanitizedUser;\n  }\n}\n\nexport default UserModel;\n"]},"metadata":{},"sourceType":"module"}