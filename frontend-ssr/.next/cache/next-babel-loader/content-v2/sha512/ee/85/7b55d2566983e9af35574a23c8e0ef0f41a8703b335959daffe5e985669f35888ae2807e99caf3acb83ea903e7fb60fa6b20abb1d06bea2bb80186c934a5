{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.__esModule = true;\nexports.compileNonPath = compileNonPath;\nexports.default = prepareDestination;\n\nvar _querystring = require(\"./querystring\");\n\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return pathToRegexp.compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(destination, params, query, appendParamsToQuery) {\n  let parsedDestination = {}; // clone query so we don't modify the original\n\n  query = Object.assign({}, query);\n  const hadLocale = query.__nextLocale;\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params);\n    }\n\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(params); // remove internal param for i18n\n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');\n  }\n\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["value","Object","key","pathToRegexp","validate","parsedDestination","query","hadLocale","destination","destQuery","destPath","pathname","destPathParamKeys","destPathParams","destinationCompiler","Array","strOrArray","compileNonPath","paramKeys","name","appendParamsToQuery","params","newUrl","hash","err"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return pathToRegexp\n    .compile(`/${value}`, { validate: false })(params)\n    .substr(1)\n}\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  const hadLocale = query.__nextLocale\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(params)\n\n  // remove internal param for i18n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter((name) => name !== 'nextInternalLocale')\n  }\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}